[{"categories":["算法和数据结构"],"content":"什么是查找？ 查找就是在数据集合中查找某种符合条件的数据元素的过程。有两种结果：查找成功、查找失败 常用的查找操作有以下四种： 查询特定数据元素是否在查找表中 检索特定数据元素的属性 在查找表中插入一个数据元素 在查找表中删除一个数据元素 根据不同的操作，可以将查找表分为如下两种类型： 静态查找表：查找操作不会更改查找表。比如从操作1、2。一般顺序查找、二分查找、散列查找适用于静态查找表。 动态查找表：查找操作会更改查找表。比如操作3、4。一般BST查找、散列查找适用于动态查找表。 衡量查找算法的主要指标是平均查找长度，其定义为：所有查找过程中进行关键字比较次数的平均值。关键字可以唯一标识一个数据元素，也就是说通过关键字查找一个数据元素，结果总是唯一的。 接下来看看常见的查找算法及其应用场景。 ","date":"2021-05-08","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/:1:0","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：查找","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法和数据结构"],"content":"顺序查找 顺序查找主要是对线性表进行查找。是所有查找算法中最直观也是最简单的查找算法。分为两种情况： 查找无序线性表 查找根据关键字排序的有序线性表 ","date":"2021-05-08","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/:2:0","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：查找","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法和数据结构"],"content":"无序线性表的顺序查找 思路：不论是顺序存储的线性表还是链式存储的线性表，只需要从线性表的一段开始，逐个检查关键字是否满足给定的条件。如若查询到满足条件的元素，则查找成功。但是如果已经查询到线性表的另一端还没有找到符合条件的元素，则宣告查找失败。 算法的Java实现： public int sequentialSearchh(int[] arr, int key){ for(int i=0; i\u003carr.length; i++){ if(arr[i]==key){ return i; } } return -1; } 平均查找长度：一般计算查找成功的平均查找长度，那么ASL=(n+1)/2。(就是从1加到n，然后再除个n) ","date":"2021-05-08","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/:2:1","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：查找","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法和数据结构"],"content":"有序线性表的顺序查找 有序线性表和无序线性表的顺序查找区别在于：无需如果查不到就一直查到最后，有序只要查到当前元素比目标元素key大，就可以不用查了。 所以可以见得，有序线性表的顺序查找ASL和无序线性表是一样的。但是它却能够以更快的速度告诉调用方查询失败。 一般来说无序线性表查询失败的ASL=n，而有序线性表查询失败的ASL一定是小于n的。 所以如果线性表已经排序了，那么使用如下算法可以快速获得查询失败的消息。 public int sequentialSearchh(int[] arr, int key){ for(int i=0; i\u003carr.length; i++){ if(arr[i]==key){ return i; }else if(arr[i]\u003ekey){ return -1; } } return -1; } ","date":"2021-05-08","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/:2:2","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：查找","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法和数据结构"],"content":"二分查找（折半查找） 二分查找仅仅适用于有序的顺序表。 思路：首先将key同顺序表中间元素进行比较，如果相等，则查找成功。如果key小于中间元素，则从顺序表的前半部分进行查找，否则从后半部分进行查找。查找过程也是同其中间元素进行比较，如此重复直到找到位置，如果确认找不到符合条件的元素，则查找失败。 二分查找有两种实现方式： 递归实现 public int binarySearch(int[] arr, int key, int low, int high){ // 判断参数是否合法 if(key\u003carr[low] || key\u003earr[high] || low\u003ehigh){ return -1; } // 然后获取中间值 int middle = (low+hight)/2; // 开始比较，符合要求返回索引，否则递归调用 if(key==arr[middle]){ return middle; }else if(key\u003carr[middle]){ return binarySearch(arr, key, low, middle-1); }else{ return binarySearch(arr, key, middle+1, high); } } 非递归实现，使用while循环 public int binarySearch(int arr[], int key){ int low = 0; int high = arr.length-1; int middlw = 0; // 判断key是否在范围内，并且arr是否有值 if(key\u003carr[low] || key\u003earr[high] || low\u003ehigh){ return -1; } // 循环更改范围以获取符合条件的数据元素 while(low\u003c=high) { middle = (low+high)/2; if(key==arr[middle]){ return middle; }else if(key\u003carr[middle]){ high = middle-1; }else{ low = middle+1; } } return -1; } 两种算法的时间复杂度都是O(logN)，ASL=(11+22+34+48+…+h*2^(h-1))≈log(n+1)-1，最后算下来是对数级别的。相较于顺序查找好了一个量级。 注意：因为二分查找要经常更改查找范围，所以要求线性表有随机读取的要求，也就是说二分查找适合顺序存储的线性表，对于链式存储的线性表则不合适。 ","date":"2021-05-08","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/:3:0","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：查找","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法和数据结构"],"content":"分块查找 分块查找则是吸取了顺序查找和二分查找各自的优点的出来的一个折中方案，所以也叫索引顺序查找。 思想：查找表分为若干块，块内部时无序的，而块之间则有序排列，按照第n块中最大关键字小于第n+1块中所有关键字的顺序排列。同时维护了一个索引表，表中记录着每块中最大关键字的值和该块首地址，索引表内部也是按照关键字排序。 查找过程： 在索引表中确定key值所在的块，可以顺序查找也可以二分查找 然后在块内顺序查找 下面来看看分块查找的性能如何。 分块查找的平均查找长度ASL由两部分组成：索引查找平均长度和块内查找平均长度。将长度为n的线性表均匀的分为b块，每块s个数据元素。 若在索引表中采取顺序查找，则ASL=(b+1)/2 + (s+1)/2 若在索引表中采取二分查找，则ASL=log(b+1) + (s+1)/2 ","date":"2021-05-08","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/:4:0","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：查找","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法和数据结构"],"content":"二叉树查找 之前记录了二叉树查找的相关知识点，这里不再赘述：二叉排序树（BST） ","date":"2021-05-08","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/:5:0","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：查找","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法和数据结构"],"content":"散列查找 之前介绍的几种查找算法都是通过key和数据元素的关键字进行比较来得出是否查找成功，而查找效率则通过比较次数来体现。但是散列查找则利用散列表的特性进行查找，理想情况下，可以在O(1)时间复杂度内查到符合条件的元素。 在认识散列表之前先来看看对散列表至关重要的散列函数：将查找表中的关键字映射成该数据元素存放地址的函数。 散列表：散列表中元素存放的地址都是通过散列函数计算得出，所以散列表可以直接使用关键字访问想要访问的数据元素。通俗讲散列表建立了关键字和存储地址间的映射关系。 ","date":"2021-05-08","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/:6:0","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：查找","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法和数据结构"],"content":"散列函数 不是随意做一个映射就可以称之为散列函数，一般来说，散列函数有如下几点要求： 散列函数定义域为所有关键字，值域为散列表的地址范围 散列函数需要将关键字的存储地址均匀的分布在地址空间内，尽可能减少冲突发生 散列函数尽量简单，可以在短时间内计算出关键字所映射的存储地址 通过上述几点要求，也随之产生了几种常见的散列函数： 直接定址 通过关键字计算出其线性函数值作为地址存储。 散列函数：H(key)=a*key+b 其中a、b均为常数。 这种情况一般不会产生冲突，如果key值大多连续可以使用这种方式，否则可能会造成地址浪费。 取余数 常用的方法之一，一般取一个不大于m的质数p作为除数，通过关键字对这个质数p取余获得地址，这种方式是否会频繁造成冲突取决于质数p的大小，一般来说质数p要不大于m但十分接近m，造成的冲突情况会相对较少。 散列函数：H(key)=key%p 不过即使p选择地再怎么精妙也是无法避免冲突的。 Java的HashMap中使用了这种方式，不过HashMap进行了两次散列，第一次对关键字进行散列获取到三劣质，然后对第一次的散列值高16位和低16为进行异或，并且将异或的结果存储为第一次散列值的低16位。这么做的原因是：在HashMap存储数据的时候会对hash函数返回的散列值进行取余，众所周知，如果除数不大，那么散列值的高位基本上不会参与到地址映射的工作当中，为了使高位也能参与到地址映射，所以进行了第二次异或散列，这样原本key的散列值高位和低位都能尽可能的参与到地址映射当中。 数字分析 关键字是r进制数字，那么我们选取关键字中变化较多的几位，通过r进制重新组合成新的数字，将这个新的数字作为地址。这种方式比较局限，因为如果关键字种类换了，那么函数也得跟着换。 折叠法 这种方法比较简单，将原本的关键字分割成若干段，然后讲这些段相加，得到地址。 平方取中 对关键字进行平方，然后取平方后的值的中间几位作为地址。 ","date":"2021-05-08","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/:6:1","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：查找","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法和数据结构"],"content":"散列冲突 上述散列函数中，除了直接定址之外，其他基本上都会产生冲突。冲突并不可怕，关键是要找到解决冲突的办法。一般解决冲突有两种办法： 开放定址法 当两个关键字地址发生冲突的时候，使用某种探测技术生成一个探测序列，然后沿着这个探测序列查找下去，如果发现空的单元，则插入。 公式：H(key)=H(key+di)%m，其中di为增量序列，m为散列表长度 增量序列有如下四种方式可以生成： 线性探测法：di=0,1,2,3,4,…,m-1，这也就是说顺着冲突的地址按照顺序往下一个一个地址去看有没有空闲，知道找到一个空地址，将元素存入。这种方式会导致元素堆积。 平方探测法：di=0^2,1^2,-1^2,2^2,-2^2,…,k^2,-k^2，其中k\u003c=m/2，并且散列表长度m必须可以表示成为4k+3的素数。这种方式可以避免堆积，但是并不能探测全部的地址空间，不过至少也能探测一般。 再散列法：di=H2(key)，通过公式Hi=(H(key) + i*H2(key))%m，的大豆再散列的值，其中i为再散列的次数，初始为0。这种方式最多经过m-1次探测就可以遍历表中所有位置，回到H0的位置。 伪随机序列法：di=伪随机数序列，称为伪随机序列法。 链接法 将同一散列地址的所有元素存储在一条线性链表中。 桶地址法 为表中的每个地址关联一个桶,一个桶可以存储多个元素.如果桶满了,可以使用开放地址法。 ","date":"2021-05-08","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/:6:2","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：查找","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法和数据结构"],"content":"性能分析 在分析性能之前，先了解一下散列表的查找过程： 通过key的散列值获取地址，检测表中对应地址是否有记录，如果没有记录，返回查找失败。如果有记录，对比记录的关键字和key是否符合，符合则返回查找成功。不符合则进入步骤2 用给定处理冲突的方式计算下一个散列地址。然后转入步骤1，使用新生成的地址查询 通过散列表查询的过程可以看出： 尽管散列表建立了关键字和存储地址之间的映射，但是由于冲突的存在，导致还是需要通过比较关键字来确定查找元素。所以还是需要使用ASL来评估性能。 散列表查找效率取决于三个因素：散列函数、处理冲突方式、填装因子（如果不知道什么是填装因子去百度）。一般来说填装因子对散列表的效率影响比较大，因为如果填装因子过大，导致填装过满，冲突会加剧。 ","date":"2021-05-08","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/:6:3","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：查找","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法和数据结构"],"content":"B树、B+树 ","date":"2021-05-08","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/:7:0","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：查找","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法和数据结构"],"content":"树的基本概念 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:1:0","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"树的定义 树是由n（n\u003e=0）个节点和n-1条边构成的有限集。 n=0，称为空树 n\u003e0，存在根节点 非空树满足如下条件： 有且仅有一个根节点 当n\u003e1时，其余节点可以分为m（m\u003e0）个互不相交的有限集，其中每个有限集都是一棵树，称为子树。 由此可见树是一种递归的数据结构，具有两个特点： 树种的根节点没有直接前驱，其余节点有且仅有一个直接前驱。 树种所有节点有0个或者多个直接后继。 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:1:1","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"描述树的术语 从节点N到根节点的任意一个节点，都成为N的祖先，N则成为这些个祖先的子孙，N的直接前驱节点成为N的双亲，K成为其直接前驱节点的孩子，有相同双亲节点的多个节点成为兄弟。 树中某个节点的孩子个数成为节点的度，树中节点的最大度数为树的度。 度大于0的节点为分支节点，度为0的节点为叶子节点。 节点的层次：以根节点所在的层数为第1层，根节点的直接子节点所在的层数为第2层，以此类推。 节点的深度：从上向下的层数。 节点的高度：从下向上的层数。 树的高度：树中节点的最大层数。 森林：森林是m（m\u003e0）棵互不相交的树的集合。 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:1:2","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"树的性质 节点数=总度数+1 度为m的树第i层至多有m^(i-1)个节点，也就是每个节点的度都是m 高度为h的m叉树，至多有(m^h - 1)*(m-1)个节点，也就是每个节点的度都是m，然后根绝等比数列公式计算所有层上的节点数之和 高度为h的m叉树至少有h个节点，高度为h，度为m的树至少有h+m-1个节点 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:1:3","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"二叉树 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:2:0","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"二叉树的定义 二叉树就是最大度数为2的有序树。何谓有序树，就是节点顺序不可颠倒的树，二叉树中分为左子树和右子树，二者不可颠倒，颠倒就成为另一个二叉树了。 特殊的二叉树： 满二叉树：高度为h且含有2^h - 1个节点的二叉树。按照从上到下、从左到右的顺序依次对节点编号。也就是从1到2^h - 1个号码。 完全二叉树：不一定是满二叉树，但是所有节点的号码与高度相同的满二叉树中对应节点号码相同的二叉树。 满二叉树和完全二叉树满二叉树和完全二叉树 \" 满二叉树和完全二叉树 二叉排序树（高频）：左子树上所有节点的号码均小于根节点，右子树上所有节点的号码均大于根节点 平衡二叉树（高频）：树上任意节点的左子树和右子树的深度只差不超过1 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:2:1","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"二叉树的性质 非空二叉树中第k层，至多有2^(k-1)个节点（k\u003e0） 高度为h的二叉树至多有2^h - 1个节点（h\u003e0） ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:2:2","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"二叉树存储结构 1. 顺序存储结构 使用一组连续的存储空间自上而下，自左至右地存储二叉树中的所有节点，如果遇到某个位置上没有节点，使用空节点来代替。 所以顺序存储结构更适合存储满二叉树和完美二叉树。 2. 链式存储结构 使用节点将指针将所有节点按照其在二叉树中的关系链接起来。 链表节点有三个域：左指针域、数据域、右指针域。 一般的二叉树都是使用链式存储结构。值得注意的是，在含有n个节点的二叉链表中，含有n+1个空链域，都是叶子节点的左指针域和右指针域。奇数个节点有偶数个空链域，偶数个节点有奇数个空链域。 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:2:3","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"二叉树的遍历 这里的遍历都是根据链式存储结构来进行的，具体的数据结构如下所示： /** * 二叉树节点的数据结构 */ public class BiTree { String data; BiTree leftChild; BiTree rightChild; public BiTree(String data, BiTree leftChild, BiTree rightChild) { this.data = data; this.leftChild = leftChild; this.rightChild = rightChild; } } ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:3:0","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"先序遍历（NLR） 二叉树为空，啥也不做 否则按照如下顺序访问节点：根节点(N)-\u003e左子树(L)-\u003e右子树(R) public void print(BiTree tree){ System.out.println(tree.data); } /** * 先序遍历 */ public void preOrder(BiTree tree) { // 判断空树 if(tree != null){ visit(tree); preOrder(tree.lchild); preOrder(tree.rchild); } } ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:3:1","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"中序遍历（LNR） 二叉树为空，啥也不做 否则按照如下顺序访问节点：左子树(L)-\u003e根节点(N)-\u003e右子树(R) public void print(BiTree tree){ System.out.println(tree.data); } /** * 中序遍历 */ public void inOrder(BiTree tree) { // 判断空树 if(tree != null){ inOrder(tree.lchild); visit(tree); inOrder(tree.rchild); } } ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:3:2","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"后序遍历（LRN） 二叉树为空，啥也不做 否则按照如下顺序访问节点：左子树(L)-\u003e右子树(R)-\u003e根节点(N) public void print(BiTree tree){ System.out.println(tree.data); } /** * 后序遍历 */ public void postOrder(BiTree tree) { // 判断空树 if(tree != null){ postOrder(tree.lchild); postOrder(tree.rchild); visit(tree); } } ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:3:3","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"非递归遍历 上述三种遍历方式都使用了递归的手法，无非就是调整一下访问当前节点数据的函数位置罢了，每个节点都只访问一次，时间复杂度为O(n)，最坏空间复杂度为O(n)。 那么问题随之而来，如果不借助递归的话，该如何对二叉树进行前序、中序、后序遍历呢？ 通过使用栈可以解决这个问题，栈的特性是先进后出(FILO)，由此可以得到如下使用非递归算法解决遍历的思路。 先序遍历 ① 从根节点开始，访问当前节点并且入栈，如果左孩子不为空，一直重复① ② 左孩子为空则开始出栈，判断当前节点的右节点是否存在，为空则继续执行②，否则执行① public void print(BiTree tree){ System.out.println(tree.data); } public void preOrderNonRecursive(BiTree tree){ // 使用链表当做栈 Deque\u003cBiTree\u003e stack = new LinkedList\u003c\u003e(); // 如果当前节点存在左孩子 或者 栈不为空 while(tree!=null || !stack.isEmpty()){ if(tree){ visit(top); stack.push(tree); tree = tree.leftChild; }else{ BiTree top = stack.pop(); tree = top.rightChild; } } } 中序遍历 ① 从根节点依次将左孩子压入栈，直到左孩子为空，表明可以出栈了 ② 从栈顶拿到一个节点读取，然后判断其右孩子是否为空，为空则继续执行②，否则执行① public void print(BiTree tree){ System.out.println(tree.data); } public void inOrderNonRecursive(BiTree tree){ // 使用链表当做栈 Deque\u003cBiTree\u003e stack = new LinkedList\u003c\u003e(); // 如果当前节点存在左孩子 或者 栈不为空 while(tree!=null || !stack.isEmpty()){ if(tree){ stack.push(tree); tree = tree.leftChild; }else{ BiTree top = stack.pop(); visit(top); tree = top.rightChild; } } } 后序遍历（三种非递归中最难） ① 从根节点开始一次将左孩子压入栈，直到左孩子为空 ② 判断当前栈顶节点是否存在右子树或者右子树被完全访问，不存在或者已被完全访问则出栈访问并且继续执行②，否则对右子树执行① public void print(BiTree tree){ System.out.println(tree.data); } public void postOrderNonRecursive(BiTree tree){ // 定义变量来标记最近访问的节点，用于判断右子树是否完全访问了 BiTree recentPop = null; // 使用链表当做栈 Deque\u003cBiTree\u003e stack = new LinkedList\u003c\u003e(); // 如果当前节点存在左孩子 或者 栈不为空 while(tree!=null || !stack.isEmpty()){ if(tree){ stack.push(tree); tree = tree.leftChild; }else{ // 如果右子树存在并且没有被访问过，压栈 tree = stack.peek(); if(tree.rightChild!=null \u0026\u0026 tree.rightChild != recentPop){ tree = tree.rightChild; stack.push(tree); tree = tree.leftChild; }else{ BiTree top = stack.pop(); visit(top); recentPop = top; // 将tree置为null，这样就会继续进入到判断栈顶元素是否存在右子树的环节了 tree = null; } // 否则访问栈顶节点，并且记录最近访问的这个节点 } } } ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:3:4","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"层序遍历 使用队列，步骤如下： 根节点开始入队 然后出队，读取根节点元素，然后将根节点的子节点从左至右入队 以此类推，知道所有元素遍历完成 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:3:5","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"二叉排序树（BST） ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:4:0","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"二叉排序树的定义 二叉排序树（BinarySortTree）又称为二叉查找树（BinarySearchTree）。除了空树以外，二叉排序树的特征如下： 若左子树非空，则左子树上所有节点的值均小于根节点的值 若右子树非空，则右子树上所有节点的值均小于根节点的值 左右子树分别也是一颗二叉排序树 由上述特征可以得到：中序遍历二叉排序树，可以得到一个递增的序列。 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:4:1","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"二叉排序树的操作 查找 先将给定的值同根节点比较，相同则查找完成。给定的值小于根节点值，在左子树查找，否则在右子树查找。 很明显，这种查找也是一个递归的过程。所以产生了两种查找算法：递归算法和非递归算法。 递归算法实现： /** * 递归算法： * 在给定的二叉查找树tree中搜索给定的key值，并且返回对应的节点 */ BiTree BSTSearch(BiTree tree, String key){ if(key==null || tree==null){ return null; } if(key.equals(tree.data)){ // 如果查找到了则返回 return tree; }else{ // 没有查找到，判断值的大小 if(key.compareTo(tree.data)\u003c0){ return BSTSearch(tree.leftChild, key); }else{ return BSTSearch(tree.rightChild, key); } } } 非递归算法实现： /** * 非递归算法： * 在给定的二叉查找树tree中搜索给定的key值，并且返回对应的节点 */ BiTree BSTSearch(BiTree tree, String key){ if(key==null) { return null; } // 当树不为空并且没有找到合适的值时，继续循环 while(tree!=null \u0026\u0026 !key.equals(tree.data)){ if(key.compareTo(tree.data)\u003c0){ tree = tree.leftChild; }else{ tree = tree.rightChild; } } return tree; } 插入 二叉树是动态树，如果没有在二叉树中找到对应的值，那么就将该值插入到二叉树里面。在这个过程中，如果原本二叉树不为空，则最后查找的节点一定是叶子节点，也就是说该值将被插入到这个叶子节点上作为其孩子。 二叉树的插入算法实现： /** * 将制定的值包装成二叉树的节点插入到二叉树当中 */ int BSTInsert(BiTree tree, String key){ if(key==null){ return 0; } if(tree==null){ // 原本的二叉树为空 tree = new BiTree(key, null, null); return 1; }else if(key.equals(tree.data)){ // 原本的二叉树中存在key值 return 0; }else if(key.compareTo(tree.data)\u003c0\u003e){ // 在左子树中查找插入 return BSTInsert(tree.leftChild, key); }else{ // 在右子树中查找插入 return BSTInsert(tree.rightChild, key); } } 删除 三种情况处理： 如若删除的节点没有左右孩子，直接删除 如若删除的节点仅有左子树或者右子树，那么删除该节点之后，让子树成为父节点的子树 如果删除的节点存在左右子树，那么使用右子树中序遍历的第一个节点A替换当前被删除节点，并且随后删除节点A，由于节点A一定是上述两种情况中的一种，所以删除起来比较方便 构造 构造的意思就是：给定一个有序序列，将其构造成二叉排序树。 思路：遍历有序序列，对其中所有的值调用BSTInsert方法进行插入，遍历完成之后就生成了二叉排序树。 效率分析 如果二叉排序树左右子树的高度差不超过1，那么平均查找长度为O(log2n) 如果二叉排序树仅有单边子树，那么平均查找长度为O(n) 同时对于插入删除这些维护操作来说，二叉排序树不会移动任意节点，秩序改变指针指向。所以平均执行时间为O(log2n)。 下面同二分查找进行对比： 查找 插入 删除 二分查找 log2n n n 二叉排序树 log2n log2n log2n 二分查找判定树唯一，而二叉排序树不唯一。 所以如果对于静态序列建议使用二分查找，对于动态序列建议使用二叉树。 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:4:2","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"平衡二叉树（AVL） 二叉排序树可能会带来树高增长过快的问题，导致一些操作算法性能上并不能发挥出其最大优势，所以引入了平衡二叉树。 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:5:0","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"平衡二叉树定义 所谓平衡二叉树，就是左右子树均为平衡二叉树，且左右子树的高度差不大于1。 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:5:1","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"平衡二叉树的插入 平衡二叉树的插入相对于普通二叉排序树的插入多了一个步骤，当节点插入完成之后，如果导致离当前插入节点路径最近的节点A进入了不平衡状态，那么还需要调整节点A的子树使其重归平衡状态。 总共有以下四种情况： LL平衡旋转（右单旋转） 向A左子树的左节点插入节点N导致节点A失衡。 LL平衡旋转动画LL平衡旋转动画 \" LL平衡旋转动画 RR平衡旋转（左单旋转） 向A右子树的右节点插入节点N导致节点A失衡。 RR平衡旋转动画RR平衡旋转动画 \" RR平衡旋转动画 LR平衡旋转（先左后右双旋转） 向A左子树的右节点插入节点N导致节点A失衡。 LR平衡旋转动画LR平衡旋转动画 \" LR平衡旋转动画 RL平衡旋转（先右后左双旋转） 向A右子树的左节点插入节点N导致节点A失衡。 RL平衡旋转动画RL平衡旋转动画 \" RL平衡旋转动画 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:5:2","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"红黑树（Red Black Tree RBT） 红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:6:0","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"红黑树的定义 红黑树：一种含有红黑结点并能自平衡的二叉排序树（BST）。 黑色高度：从根节点到叶子节点的路径上黑色节点的个数，叫做树的黑色高度。 红黑树常用的性质： 节点要么黑色要么红色 根节点是黑色 每个叶子节点是黑色，并且都是空节点（Java 实现的红黑树将使用 null 来代表空节点，遍历红黑树时将看不到黑色的叶子节点，反而看到每个叶子节点都是红色的） 每个红色节点的两个子节点都一定是黑色 任意一结点到每个叶子结点的路径都包含数量相同的黑结点，即左子树和右子树的黑结点的层数是相等的，所以称红黑树为黑色完美平衡 红黑树并不是标准平衡二叉树，它以性质 5 作为一种平衡方法，使自己的性能得到了提升。 红黑树通过三个操作来保证自平衡：左旋、右旋、着色。其中左旋和右旋和平衡二叉树的LL、RR类似，着色就是将节点颜色由黑变红或者由红变黑。 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:6:1","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"红黑树的插入 红黑树的插入分为两个步骤： 像BST一样进行查找，然后插入 调整红黑树的结构，保证满足红黑树的性质：左旋、右旋、着色操作 所以研究红黑树的插入，重点研究的是红黑树如何在插入后调整结构达到自平衡。 下面是插入过程中字母所表示的节点： 插入过程中节点名称插入过程中节点名称 \" 插入过程中节点名称 插入后调整思路 如果插入根节点，那么直接插入改为黑色即可 如果不是根节点，则需要关注父节点P是否为红色：如果P为黑色，插入后不需要调整；如果P为红色，表明N和P颜色冲突了，这个时候就需要使用父兄节点U来进行旋转操作，使红黑树达到平衡。 U为红色，那么P、U都置为黑色，G置为红色，解决了红色冲突，并且保证了黑色层数不变，但随之带来了另一个问题，G和G的父节点是否会红色冲突呢？如果冲突就需要将G重新作为新增节点N重复插入操作了。 U为黑色，为了解决红色冲突，需要将一个红色插入到另一边的两个黑色之间，那么这个时候进行旋转即可达到效果，具体情况下图有详细说明。 红黑树插入思路红黑树插入思路 \" 红黑树插入思路 具体调整情况 父亲节点为红色，叔叔节点为红色，祖父节点为黑色 假设插入节点N，N为红色，那么为了保证性质4，则父亲节点必须更改为黑色，同时祖父节点更改为红色，随之带来的就是叔叔节点更改为黑色。 情况1着色更改情况1着色更改 \" 情况1着色更改 上述着色更改之后，带来一个问题，就是祖父节点改为红色之后，其父亲节点会不会也是红色，解决办法：如果祖父节点的父亲节点也是红色，那么就将祖父节点当成新添加的节点，继续重复上述操作，知道不会出现两个红色节点相连为止。 情况1中新节点插入到左节点和右节点处理方式相同，故不做其他说明。 父亲节点为红色，叔叔节点为黑色，祖父节点为黑色 假设插入节点N，N为红色，那么为了保证性质4，把父亲节点更改为黑色，那么多了一个黑色节点，违背性质5。仅仅改色目前看上去不太行了，那么只能旋转了。 目前看来右旋比较合适，因为左旋会导致叔叔路径上少了一个黑色节点。将父亲节点作为根节点，祖父节点作为父亲节点的子节点，叔叔节点还是祖父节点的子节点。旋转完成之后，父亲节点作为根节点是黑色，新增节点是红色，祖父节点改为红色，叔叔节点保持黑色，这样就完成了调整。 情况2旋转+着色情况2旋转+着色 \" 情况2旋转+着色 如果节点N插入在父亲节点的右节点，那么在进行情况2之前还需要对节点P进行一次左旋，然后在进行右旋-着色的操作。 情况2插入右节点先左旋情况2插入右节点先左旋 \" 情况2插入右节点先左旋 总结完之后发现这种情况不存在，因为祖父节点左子树和右子树的黑色层数不同。目前是这么认为的，如果有思维盲点欢迎指正。 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:6:2","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"红黑树的删除 红黑树的删除也同样分为两个步骤： BST删除节点操作 结构调整 删除过程中的字母标识如下所示： 删除过程中节点名称删除过程中节点名称 \" 删除过程中节点名称 BST删除节点操作回顾 前面说了BST删除节点有如下三种情况： 如若删除的节点没有左右孩子，直接删除 如若删除的节点仅有左子树或者右子树，那么删除该节点之后，让子树成为父节点的子树 如果删除的节点存在左右子树，那么使用右子树中序遍历的第一个节点A替换当前被删除节点，并且随后删除节点A，由于节点A一定是上述两种情况中的一种，所以删除起来比较方便 三种情况过于复杂，不过自己看图按照删除的流程走了几遍之后，发现了一个思路： 所有的上述三种情况，最终删除的都是叶子节点，也就是情况1。 如果按照上述三种情况来解释未免有点牵强，所以将上述三种删除情况改进一下： 叶子节点直接删除 如果删除的节点有左子树或者右子树，首先取右子树最左节点A（如果没有右子树则取左子树最右节点）替换当前删除节点，如果替换节点A也存在子树，那么继续使用其子树中的节点替换A，直到最后一个替换节点Z不存在子节点，也就是说最后的节点Z是叶子节点，那么删除Z即可。 从改进的之后的情况中可以发现，我们可以认为最终删除的都是叶子节点。 删除后的调整思路 对于红色的叶子节点，删除之后并不会影响红黑树的平衡，所以只需要关注黑色叶子节点的删除。 而删除了黑色节点表示有一边少了一层黑色，有两种处理方式： 将另一边也减少一层黑色，然后再以父节点P作为节点N继续执行删除操作，进行递归处理 通过一系列高端操作，让删除的这边增加一层黑色，从而达到平衡 上面说起来很简单，可以通过以下故事通俗理解： 假如说，我需要2枚硬币，这时候我们一般的做法可以看做下面几步： 自己有吗？（） 自己没有的话，兄弟有吗？ 兄弟没有的话，兄弟的孩子有吗？ 连兄弟的孩子都没有的话？那我们会托父母找亲戚看看有没有 下面是总结的删除思维导图： 红黑树删除思路红黑树删除思路 \" 红黑树删除思路 具体调整情况 删除的叶子节点N为根节点 无需自平衡。 删除的叶子节点N有兄弟节点S 2.1. 兄弟节点S为红色（表明可以借用兄弟节点的红色） S为P的左节点，以P为轴进行右旋，S、P交换颜色 S为红色左节点2.1-1 \" S为红色左节点 S为P的右节点，以P为轴进行左旋，S、P交换颜色 S为红色右节点2.1-2 \" S为红色右节点 2.2. 兄弟节点S为黑色（表明无法借用兄弟节点的红色，那么我们看看兄弟节点的孩子） 2.2.1 兄弟节点S的孩子均为黑色（也无法借用兄弟节点孩子的红色） P为红色：S和P交换颜色 P为红色2.2.1-1 P为红色 \" P为红色 P为黑色：S变为红色，将P当做N做递归删除处理（这里P的两遍黑色层数都减少了1） P为黑色2.2.1-2 P为黑色 \" P为黑色 2.2.2 兄弟节点S的孩子存在红色 SL红：按照下图，以P为轴进行右旋，S变为新P，同时S置为P的颜色，P变为黑色，SL变为黑色，SR变为P的左子节点。 SL红2.2.2-1 SL红 \" SL红 SL黑、SR红：分为两步走，1. 以S为轴进行左旋，SR变为P的左子节点，S变为SR的左子节点，SL还是S的左子节点，同时交换SR与S的颜色，此时SR是黑色，S是红色；2. 此时情况转换为了上述情况，以P为轴进行右旋，SR变为了新P，同时SR置为P的颜色，P变为黑色，S变为黑色 SL黑、SR红2.2.2-2 SL黑、SR红 \" SL黑、SR红 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:6:3","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"红黑树的疑问 经过了上述插入删除两个操作的学习，对红黑树有了更深入的了解。接下来看看红黑树的几个问题： 1. 红黑树根节点为什么是黑色的？ 因为如果根节点是红色，那么想要给只有一个根节点的红黑树中插入元素就需要转换颜色或者进行旋转，用来达到所有路径上的黑色层数相同。所以如果根节点本身就是黑色，那就不用那么麻烦，说白了就是懒。 2. 为什么不能有两个连续的红色节点？ 为了保证路径长度的相对平衡，因为所有路径上的黑色层数n都相同，从根节点到叶子节点的最短路径一定全是黑色节点，故路径长度为n，而最长路径则是相连的两个黑色节点中间都插入一个红色节点，故路径长度为2n，这就保证了即使是最长的路径也只是最短路径的2倍。 3. 红黑树的效率怎么样？ 查找时间复杂度：查找自然不用多说，RBT的查找时间复杂度为O(logN)，但是相比AVL的还是要逊色不少，因为AVL是严格平衡二叉树，子树高度差不超过1，也就是说从根节点到任何叶子节点路径长度大致相同，而RBT从根节点到叶子节点所有路径长度最大差值为一倍黑色层高。 插入和删除时间复杂度：RNT的插入和删除时间复杂度和查询时间复杂度相当，是O(logN)（具体怎么证明，后面再补充，已经学费了） 由于RBT不想AVL一样追求完美平衡，所以插入和删除操作过程中的平衡操作比AVL少了不少。但是RBT又能保证黑色平衡，相比BST要好了不少。所以个人理解RBT就是BST和AVL的一个折中。具体使用还得看场景，没有孰好孰不好。 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:6:4","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"哈弗曼树与哈夫曼编码 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:7:0","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"哈弗曼树的定义 了解什么是哈弗曼树之前，首先了解下面这些定义： 权：树中节点被赋予的一个有意义的值，成为该节点的权值。 带权路径长度：从树的根节点到节点N上的路径长度与节点N的权值的乘积，称为带权路径长度。使用WPL表示。 有了权值和带权路径长度，就可以很轻松地定义一个哈弗曼树了： 哈弗曼树：在含有n个（n\u003e0）带权叶节点的二叉树中，其中带权路径长度WPL最小的二叉树成为哈弗曼树，也叫做最优二叉树。 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:7:1","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"构造哈弗曼树 构造步骤： 将n个节点分别当做n棵树来对待，他们就构成了森林F 构造一个新节点，从森林当中拿出两个权值最小的树，将这两棵树分别作为新节点的左右子树，得到的新树的权值即为左右两个节点的权值之和 从森林F中删除刚才选中的两棵树，将新生成的子树添加到森林F中 重复步骤2、3，直到森林F中只剩下一棵树，那么这棵树就是所谓的哈弗曼树 通过上述步骤可以总结出哈弗曼树的特点： 每个初始节点最注重都成为了叶子节点，并且权值越小距离跟节点路径越长 构造过程中共新建了n-1个新节点，所以哈弗曼树总共具有2n-1个节点 哈弗曼树不存在度为1的节点，所有节点的度要么0要么2 ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:7:2","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["算法和数据结构"],"content":"哈夫曼编码 固定长度编码：每个字符使用相等长度的二进制编码。 可变长度编码：允许对不同字符使用不同长度的二进制编码。 上述两种编码，当然是可变长度编码好了，可以对高频字符使用更短长度的编码，对低频字符的编码可以更长一点，从而达到压缩数据的效果。 而哈夫曼编码就是用字符出现的频次作为其权值，出现次数越少，路径越长，出现次数越多路径越短。对于哈弗曼树，规定权值为字符出现的频次，每次向左表示0，向右表示1，则构建出了如下示例的哈弗曼树，其中叶子节点的值分别是ABCD： 哈弗曼编码示例哈弗曼编码示例 \" 哈弗曼编码示例 如果根据上图有一串编码0011011110，需要将这串编码翻译出来，那么得到的结果是AACDB，可以发现所有ABCD四个字母对应的编码互相都不是其他字母编码的前缀，这样就可以很轻松的根据前缀来识别出具体的编码。（考试千万不要用来干坏事哦[狗头]） ","date":"2021-05-06","objectID":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/:7:3","tags":["笔记","数据结构","基础"],"title":"数据结构基础知识：树","uri":"/2021/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%A0%91/"},{"categories":["游戏"],"content":"棋盘和棋子 ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:1:0","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"棋盘 国象的棋盘是由8行8列功64个方块组成 ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:1:1","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"棋子 国象共有32枚棋子，黑白两方各有16个旗子。 以白方为例（黑方棋子组成相同），包括如下： 1个王（King） 棋盘中最重要的棋子，但并不是最有威力的。 如何移动：王可以向任意方向移动一个方块 王王可以向任意方向移动一个方块 \" 王 1个后（Queen）： 棋盘中威力最大的棋子。 如何移动：后可以向前、后、左、右以及斜线共8个方向移动任意个方块 是否可以跨越棋子：不可以 后后可以向前、后、左、右以及斜线共8个方向移动任意个方块 \" 后 2个车（Rook）： 棋盘中威力仅次于后的棋子。 如何移动：车可以向前、后、左、右四个方向移动任意个方块 是否可以跨越棋子：不可以 车车可以向前、后、左、右四个方向移动任意个方块 \" 车 2个象（Bishop）： 棋盘中威力仅次于后的棋子。 如何移动： 象可以向斜线上的四个方向移动任意个方块，分为白象和黑象，白象始终在白格中移动，黑象始终在黑格中移动 是否可以跨越棋子： 不可以 象象可以向斜线上的四个方向移动任意个方块，分为白象和黑象，白象始终在白格中移动，黑象始终在黑格中移动 \" 象 2个马（Knight）： 棋盘中行进路线最特殊的棋子，当然也是最有趣的棋子。 如何移动：马不走直线，走L型，象没走一次都会调到与当前颜色相反的方块上 是否可以跨越棋子： 可以，马是国象中唯一一个可以跨越其他棋子的棋子 马马不走直线，走L型，象没走一次都会调到与当前颜色相反的方块上 \" 马 8个兵（Pawn）： 其实兵看上去有些卑微，但是它是国际象棋的灵魂，也是其中最有威力的棋子之一。 如何移动：兵的行进规则有些特殊 兵只能向前移动，且每次只能移动一格 如果是第一次前进，那么兵可以自行选择移动一格或者两格 兵是国象中唯一不能后退的棋子 是否可以跨越棋子：否 兵\" 兵 兵的升变 升变时机：当兵走到棋盘另一边的格子中，兵必须进行升变，也就是说兵必须变为其他类型的棋子 升变选项：后、车、象、马（因为每一方只能有一个王，所以兵不能升变成为王） 兵的升变\" 兵的升变 ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:1:2","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"棋盘摆放 棋盘的摆放规则：浅色格子必须在棋盘的右下角 棋子的摆放规则： 同颜色的棋子需要放在同一边 所有的兵都放在各自方从离自己最近的第二行上 将所有的车放在棋盘的四个角上的格子里 在车的旁边放上所有的马 在马的旁边放上所有的象 白色的后放在白色方最近一行中剩余的白色格子里，黑色的后放在黑色防最近一行中剩余的黑色格子里 各方最近一行中最后的那个位置就是王的位置 国象初始棋盘布局\" 国象初始棋盘布局 ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:1:3","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"游戏目标 将死对方的King或者和棋。 ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:1:4","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"基本规则 ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:2:0","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"吃（capture捕获） 当棋子的终点落在对方棋子所在的格子里，那么这个格子里对方的棋子将要从棋盘中移除掉，叫做吃（capture捕获）。 ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:2:1","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"将军（check） 当一个棋子下一步可以吃掉对方的王的时候，我们称之为将军（check）。当某一方被将军时，必须首先解除将军。 ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:2:2","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"双将（double check） 当一方的王被两个棋子同时将军，称为双将。 ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:2:3","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"解除将军（out of check） 有三种方式： 移动王到没有被将军的格子里 用己方的另一枚棋子阻塞将军，也就是挡在对方棋子和己方的王之间（双将不能用） 最好的方式是吃掉将军的棋子（双将不能用） ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:2:4","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"将死（checkmate） 如果一方被将军，并且不能通过移动、阻塞、吃棋来到到解除将军的目的，那我们成这种情况叫做将死，这表示被将死的一方输了，而对方赢了。最快速的将死只需要两步棋： 将死示例\" 将死示例 ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:2:5","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"和棋（stalemate） 一方即使没有被将军，但是也没有任何可以走的棋，那么当这种情况放生时，棋局的结果是和棋，没有输赢。如下所示就是一种和棋的情况，轮到白方走了，但是白方无论怎么走都会被将军，所以成了和棋： 和棋stalemate示例\" 和棋stalemate示例 ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:2:6","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"其他和棋（draw） 双方都同意和棋的情况下可以和棋。有如下几种方式会造成和局： 一般时发生在对弈双方都没有一种能够获胜的方式的情况下，一方可以请求和棋，如果对方同意和棋，那么对弈以和棋结束，否则继续进行对弈。 完全相同的位置重复出现了三次，则被迫和局。网上一般是五次重复则自动和棋。 双方都只剩下王的情况下，和棋。 棋局已经在没有任何吃子的情况下进行了50步，和棋。 ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:2:7","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"王车易位（castling） 这个规则的发明是为了加速游戏的进程，因为车前期总是被挤在角落里无法加入战场。这也是国象中唯一一种可以一步走两个子的走法。具体走法：王可以向左边行进两格，左边的车同时行进到王右边的格子中；王也可以向右边行进两格，右边的车同时行进到王左边的格子中。也分为短易位和长易位。进行王车易位的前提： 王和需要被易位对从开局以来没有移动过 王和需要被易位的车之间没有其他棋子 王不能被将军 王的行进路线也不能在对方棋子的攻击范围内 ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:2:8","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"吃过路兵（En Passant） 当兵第一次行进两格时，由于没有给对面的兵吃子的机会，那么对面的兵可以按照这个行进一格的位置进行吃操作。 ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:2:9","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"国象的术语 ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:3:0","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"棋盘坐标 棋盘中的行叫做rank，从白色方的底边到黑色方的底边分别为1、2、3、4、5、6、7、8 rank 棋盘中的列叫做file，从白色方左边到白色方右边分别为a、b、c、d、e、f、g、h file ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:3:1","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"棋格名称 由于坐标的存在，所以棋盘中每个格子都有自己独一无二的名字，格式：file名字+rank名字，比如a1、e5、h8等等 ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:3:2","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"棋子简称 每个棋子都有简称，一般来说都是棋子名称开头首字母大写。 王简称K（King的首字母） 后简称Q（Queen的首字母） 车简称R（Rook的首字母） 马简称N（英文Knight的首字母是K，但是王已经用了K，所以采取第二个字母N作为马的简称） 象简称B（Bishop的首字母） 兵没有简称（也就是没有名字的那个棋子就是兵，卑微到不配拥有姓名，哈哈哈） ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:3:3","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["游戏"],"content":"棋子移动术语 国际象棋中通过 棋子简称+棋子到达的棋格名称 描述棋子的动向。而且一般会用不同颜色的字体或者背景表示双方的棋子移动。 棋子的移动：棋子简称+目标棋格。比如Ke2表示王将要走到e2。 兵的移动：只需要写出 目标棋格。比如e5表示兵将要移动到e5中。 吃：棋子简称+x+目标棋格。比如Qxe5表示后移动到e5并且吃掉e5中原先的棋子。 兵吃掉另一个棋子：兵所在的列（file）名+x+目标棋格。比如bxa8表示b file的兵移动到a8并且吃掉a8中原来的棋子。 兵的升变：兵所在的列+=+升变的棋子简称。比如b=Q表示b file的兵移动到8 file并且升变为后。又比如bxa8=Q表示b file的兵移动到a8并且吃掉a8中原来的棋子，然后升变为后。 将军：棋子简称+目标棋格++。比如Ng6+表示马走到g6，并且将军，其中+表示将军的意思，双将就是++喽。 王车易位：白方的King side和黑方的Queen side（短易位）用0-0表示；白方的Queen side和黑方的King side（长易位）用0-0-0表示。 将杀：棋子简称+目标棋格+#。 白胜：1-0或1:0 黑胜：0-1或0:1 ","date":"2021-04-27","objectID":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/:3:4","tags":["游戏","国象","入门"],"title":"国际象棋新手入门","uri":"/2021/04/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"},{"categories":["Blog"],"content":" lng [必需] (第一个位置参数): 地图初始中心点的经度, 以度为单位. lat [必需]（第二个参数位置）: 地图初始中心点的纬度, 以度为单位. zoom [可选]（第三个位置参数）: 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数): 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数): 浅色主题的地图样式, 默认值是config.toml中配置的值. dark-style [可选]（第六个位置参数）: 深色主题的地图样式，默认值是config.toml中配置的值. navigation [可选]: 是否添加 NavigationControl, 默认值是config.toml中配置的值. geolocate [可选]: 是否添加GeolocateControl, 默认值是config.toml中配置的值. scale [可选]: 是否添加ScaleControl, 默认值是config.toml中配置的值. fullscreen [可选]: 是否添加 FullscreenControl, 默认值是config.toml中配置的值. width [可选]: 地图的宽度, 默认值是 100%. height [可选]: 地图的高度, 默认值是 20rem. {{\u003c mapbox 111.003 35.022 12 \u003e}} 或者 {{\u003c mapbox lng=111.003 lat=35.022 zoom=12 \u003e}} 或者 可以通过如下方式自定义地图样式： {{\u003c mapbox 121.554 31.292 10 false \"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 或者 {{\u003c mapbox lng=121.554 lat=31.292 zoom=10 marked=false light-style=\"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} ","date":"2020-07-04","objectID":"/2020/07/mapbox%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/:0:0","tags":["文档","Shortcodes","Markdown"],"title":"Mapbox使用文档","uri":"/2020/07/mapbox%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"},{"categories":null,"content":"关于我 ","date":"2020-07-03","objectID":"/about/:0:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"工作经历 2018年毕业于上海理工大学，随后开启了Java的旅程。 2018年中-2020年初：在上海做Java工程师，主要负责公司框架组的相关工作。 2020年至今：辞职回家考研。 ","date":"2020-07-03","objectID":"/about/:1:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":["效率"],"content":"之前使用的是有道云笔记，有两个问题： Mac版的有道云笔记越来越卡了，不知道以后会不会改善 免费账户Markdown不能上传图片（没错，我的会员到期，我本可以继续付费，但我不愿意哈哈哈哈哈🤣） 当初使用有道云笔记是因为界面十分美观而且它的目录结构是类似于文件夹的，所以没有使用印象笔记。但是上述问题（主要还是第1个）让我十分不能忍，俗话说：自己动手，丰衣足食，所以果断上网查找解决办法，并且将其记录下来。 ","date":"2020-07-03","objectID":"/2020/07/%E5%9D%9A%E6%9E%9C%E4%BA%91-vscode%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%AC%94%E8%AE%B0/:0:0","tags":["工具","笔记"],"title":"坚果云 + VSCode搭建个人云笔记","uri":"/2020/07/%E5%9D%9A%E6%9E%9C%E4%BA%91-vscode%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%AC%94%E8%AE%B0/"},{"categories":["效率"],"content":"0. 选型 为什么使用坚果云（个人免费账户）？ 存储文件速度快、稳定 可以多端同步不受限制 对于笔记来说，每个月的上传下载流量是绰绰有余的 最重要的是，可以多人协同办公，可以说是十分方便了 坚果云免费账户坚果云免费账户 \" 坚果云免费账户 为什么使用VSCode? 因为我之前是搞Java的，工作中需要写一点前端（负责公司工作流的前后端维护和开发）和各种文档，VSCode轻量、跨平台、扩展丰富（可玩性极高）并且界面还很酷，一下子就爱上了。所以使用VSCode我是十分愿意的，安装插件之后，写Markdown也是很爽，一些常用功能都有。 ","date":"2020-07-03","objectID":"/2020/07/%E5%9D%9A%E6%9E%9C%E4%BA%91-vscode%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%AC%94%E8%AE%B0/:1:0","tags":["工具","笔记"],"title":"坚果云 + VSCode搭建个人云笔记","uri":"/2020/07/%E5%9D%9A%E6%9E%9C%E4%BA%91-vscode%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%AC%94%E8%AE%B0/"},{"categories":["效率"],"content":"1. 创建Github仓库 进入Github创建一个仓库，配置如下图所示，该仓库用于存储笔记中的图片。 仓库必须要是public的，否则上传会失败! Github创建仓库进入Github创建一个仓库，用于存放图片 \" Github创建仓库 ","date":"2020-07-03","objectID":"/2020/07/%E5%9D%9A%E6%9E%9C%E4%BA%91-vscode%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%AC%94%E8%AE%B0/:2:0","tags":["工具","笔记"],"title":"坚果云 + VSCode搭建个人云笔记","uri":"/2020/07/%E5%9D%9A%E6%9E%9C%E4%BA%91-vscode%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%AC%94%E8%AE%B0/"},{"categories":["效率"],"content":"2. 获取Github Token 进入Github的Settings-\u003eDeveloper Settings-\u003ePersonal access tokens-\u003eGenerate new token，然后按照如下步骤，完成之后记住token。 Github生成Token生成Token，这样PicGo可以使用token将图片上传到仓库 \" Github生成Token ","date":"2020-07-03","objectID":"/2020/07/%E5%9D%9A%E6%9E%9C%E4%BA%91-vscode%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%AC%94%E8%AE%B0/:3:0","tags":["工具","笔记"],"title":"坚果云 + VSCode搭建个人云笔记","uri":"/2020/07/%E5%9D%9A%E6%9E%9C%E4%BA%91-vscode%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%AC%94%E8%AE%B0/"},{"categories":["效率"],"content":"3. 安装PicGo并设置 如果只是依赖坚果云来存储所有笔记及其附属文件的话，那么会出现问题：在电脑上使用VSCode编辑了笔记，然后在手机上使用坚果云查看这个文档，图片就会显示不出来。 解决办法: 使用Github仓库作为图床，将图片放到Github仓库中，然后生成一个该图片的连接，在Markdown文档中使用这个图片链接即可显示图片。 在网上发现了有人使用PicGo这个VSCode插件，发现十分不错，安装插件之后可以直接使用快捷键将本地文件系统的图片或者剪贴板的图片直接上传到图片仓库中。 打开VSCode，安装插件PicGo，完成之后，点开Settings，找到如下位置开始配置 配置PicGo按照如图所示的配置项配置，其他选项按需配置 \" 配置PicGo 总共6个步骤，这里解释一下步骤3，因为github的服务器不在中国大陆，所以直接使用github做图床非常慢，这里通过使用jsDelivr这个网站中的CDN的url进行自定义加速，格式是https://cdn.jsdelivr.net/gh/你的Github用户名/图床仓库。 ","date":"2020-07-03","objectID":"/2020/07/%E5%9D%9A%E6%9E%9C%E4%BA%91-vscode%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%AC%94%E8%AE%B0/:4:0","tags":["工具","笔记"],"title":"坚果云 + VSCode搭建个人云笔记","uri":"/2020/07/%E5%9D%9A%E6%9E%9C%E4%BA%91-vscode%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%AC%94%E8%AE%B0/"},{"categories":["效率"],"content":"4. PicGo使用方法 使用阶段，在markdown文档当中，使用如下快捷键，即可将图片上传到上述创建的Github仓库的指定路径下，并且获取到图片的地址（会按照文档的类型自动写好的）。 option + command + u: 将剪贴板中的图片上传，如果剪贴板中没有图片，那么会报错。上传成功后，剪贴板内容变为该图片的仓库地址，直接粘贴即可。 option + command + e: 将文件系统中的图片上传。 ","date":"2020-07-03","objectID":"/2020/07/%E5%9D%9A%E6%9E%9C%E4%BA%91-vscode%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%AC%94%E8%AE%B0/:5:0","tags":["工具","笔记"],"title":"坚果云 + VSCode搭建个人云笔记","uri":"/2020/07/%E5%9D%9A%E6%9E%9C%E4%BA%91-vscode%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%AC%94%E8%AE%B0/"},{"categories":["效率"],"content":"5. 文档分享解决方案 由于坚果云限制了付费用户才可以分享文档，所以为了可以分享文档，需要在VSCode中安装插件Markdown Preview Enhance。 使用方法：首先在markdown源文件当中点击右键，选择Markdown Preview Enhance:...选项，那么会在当前源文件右边出现一个预览窗口，这个预览窗口当中右键，即可实现导出为各种格式。 目前支持的格式有：HTML,PDF,PNG,JPEG,ePub,mobi,Pandoc，足以支持日常使用了。 ","date":"2020-07-03","objectID":"/2020/07/%E5%9D%9A%E6%9E%9C%E4%BA%91-vscode%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%AC%94%E8%AE%B0/:6:0","tags":["工具","笔记"],"title":"坚果云 + VSCode搭建个人云笔记","uri":"/2020/07/%E5%9D%9A%E6%9E%9C%E4%BA%91-vscode%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%BA%91%E7%AC%94%E8%AE%B0/"}]