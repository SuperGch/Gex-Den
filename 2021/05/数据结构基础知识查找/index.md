# 数据结构基础知识：查找


## 什么是查找？

`查找`就是在数据集合中查找某种符合条件的数据元素的过程。有两种结果：查找成功、查找失败

常用的查找操作有以下四种：

1. 查询特定数据元素是否在查找表中
2. 检索特定数据元素的属性
3. 在查找表中插入一个数据元素
4. 在查找表中删除一个数据元素

根据不同的操作，可以将查找表分为如下两种类型：

1. `静态查找表`：查找操作不会更改查找表。比如从操作1、2。一般顺序查找、二分查找、散列查找适用于静态查找表。
2. `动态查找表`：查找操作会更改查找表。比如操作3、4。一般BST查找、散列查找适用于动态查找表。

衡量查找算法的主要指标是`平均查找长度`，其定义为：所有查找过程中进行关键字比较次数的平均值。`关键字`可以唯一标识一个数据元素，也就是说通过关键字查找一个数据元素，结果总是唯一的。

接下来看看常见的查找算法及其应用场景。

<br><br><br>

## 顺序查找

顺序查找主要是对线性表进行查找。是所有查找算法中最直观也是最简单的查找算法。分为两种情况：

1. 查找无序线性表
2. 查找根据关键字排序的有序线性表

<br>

### 无序线性表的顺序查找

`思路`：不论是顺序存储的线性表还是链式存储的线性表，只需要从线性表的一段开始，逐个检查关键字是否满足给定的条件。如若查询到满足条件的元素，则查找成功。但是如果已经查询到线性表的另一端还没有找到符合条件的元素，则宣告查找失败。

算法的Java实现：
```java
public int sequentialSearchh(int[] arr, int key){
    for(int i=0; i<arr.length; i++){
        if(arr[i]==key){
            return i;
        }
    }
    return -1;
}
```

`平均查找长度`：一般计算查找成功的平均查找长度，那么ASL=(n+1)/2。(就是从1加到n，然后再除个n)

<br>

### 有序线性表的顺序查找

有序线性表和无序线性表的顺序查找区别在于：无需如果查不到就一直查到最后，有序只要查到当前元素比目标元素key大，就可以不用查了。

所以可以见得，有序线性表的顺序查找ASL和无序线性表是一样的。但是它却能够以更快的速度告诉调用方查询失败。

一般来说无序线性表查询失败的ASL=n，而有序线性表查询失败的ASL一定是小于n的。

所以如果线性表已经排序了，那么使用如下算法可以快速获得查询失败的消息。

```java
public int sequentialSearchh(int[] arr, int key){
    for(int i=0; i<arr.length; i++){
        if(arr[i]==key){
            return i;
        }else if(arr[i]>key){
            return -1;
        }
    }
    return -1;
}
```

<br><br><br>

## 二分查找（折半查找）

二分查找仅仅适用于有序的顺序表。

`思路`：首先将key同顺序表中间元素进行比较，如果相等，则查找成功。如果key小于中间元素，则从顺序表的前半部分进行查找，否则从后半部分进行查找。查找过程也是同其中间元素进行比较，如此重复直到找到位置，如果确认找不到符合条件的元素，则查找失败。

二分查找有两种实现方式：

1. 递归实现

```java
public int binarySearch(int[] arr, int key, int low, int high){
    // 判断参数是否合法
    if(key<arr[low] || key>arr[high] || low>high){
        return -1;
    }

    // 然后获取中间值
    int middle = (low+hight)/2;

    // 开始比较，符合要求返回索引，否则递归调用
    if(key==arr[middle]){
        return middle;
    }else if(key<arr[middle]){
        return binarySearch(arr, key, low, middle-1);
    }else{
        return binarySearch(arr, key, middle+1, high);  
    }
}
```

2. 非递归实现，使用while循环

```java
public int binarySearch(int arr[], int key){
    int low = 0;
    int high = arr.length-1;
    int middlw = 0;

    // 判断key是否在范围内，并且arr是否有值
    if(key<arr[low] || key>arr[high] || low>high){
        return -1;
    }

    // 循环更改范围以获取符合条件的数据元素
    while(low<=high) {
        middle = (low+high)/2;
        if(key==arr[middle]){
            return middle;
        }else if(key<arr[middle]){
            high = middle-1;
        }else{
            low = middle+1;
        }
    }
    return -1;
}
```

两种算法的时间复杂度都是O(logN)，ASL=(1*1+2*2+3*4+4*8+...+h*2^(h-1))≈log(n+1)-1，最后算下来是对数级别的。相较于顺序查找好了一个量级。


>`注意`：因为二分查找要经常更改查找范围，所以要求线性表有随机读取的要求，也就是说二分查找适合顺序存储的线性表，对于链式存储的线性表则不合适。

<br><br><br>

## 分块查找

分块查找则是吸取了顺序查找和二分查找各自的优点的出来的一个折中方案，所以也叫`索引顺序查找`。

`思想`：查找表分为若干块，块内部时无序的，而块之间则有序排列，按照第n块中最大关键字小于第n+1块中所有关键字的顺序排列。同时维护了一个索引表，表中记录着每块中最大关键字的值和该块首地址，索引表内部也是按照关键字排序。

`查找过程`：
1. 在索引表中确定key值所在的块，可以顺序查找也可以二分查找
2. 然后在块内顺序查找

下面来看看分块查找的性能如何。

分块查找的平均查找长度ASL由两部分组成：索引查找平均长度和块内查找平均长度。将长度为n的线性表均匀的分为b块，每块s个数据元素。

1. 若在索引表中采取顺序查找，则ASL=(b+1)/2 + (s+1)/2
2. 若在索引表中采取二分查找，则ASL=log(b+1) + (s+1)/2

<br><br><br>

## 二叉树查找

之前记录了二叉树查找的相关知识点，这里不再赘述：[二叉排序树（BST）](../数据结构基础知识树#二叉排序树bst)

<br><br><br>

## 散列查找

之前介绍的几种查找算法都是通过key和数据元素的关键字进行比较来得出是否查找成功，而查找效率则通过比较次数来体现。但是散列查找则利用散列表的特性进行查找，理想情况下，可以在O(1)时间复杂度内查到符合条件的元素。

在认识散列表之前先来看看对散列表至关重要的`散列函数`：将查找表中的关键字映射成该数据元素存放地址的函数。

`散列表`：散列表中元素存放的地址都是通过散列函数计算得出，所以散列表可以直接使用关键字访问想要访问的数据元素。通俗讲散列表建立了关键字和存储地址间的映射关系。

### 散列函数

不是随意做一个映射就可以称之为散列函数，一般来说，散列函数有如下几点要求：

1. 散列函数定义域为所有关键字，值域为散列表的地址范围
2. 散列函数需要将关键字的存储地址均匀的分布在地址空间内，尽可能减少冲突发生
3. 散列函数尽量简单，可以在短时间内计算出关键字所映射的存储地址

通过上述几点要求，也随之产生了几种常见的散列函数：

1. **直接定址**

    通过关键字计算出其线性函数值作为地址存储。

    散列函数：H(key)=a*key+b

    其中a、b均为常数。

    这种情况一般不会产生冲突，如果key值大多连续可以使用这种方式，否则可能会造成地址浪费。

2. **取余数**

    常用的方法之一，一般取一个不大于m的质数p作为除数，通过关键字对这个质数p取余获得地址，这种方式是否会频繁造成冲突取决于质数p的大小，一般来说质数p要不大于m但十分接近m，造成的冲突情况会相对较少。

    散列函数：H(key)=key%p

    不过即使p选择地再怎么精妙也是无法避免冲突的。

    Java的HashMap中使用了这种方式，不过HashMap进行了两次散列，第一次对关键字进行散列获取到三劣质，然后对第一次的散列值高16位和低16为进行异或，并且将异或的结果存储为第一次散列值的低16位。这么做的原因是：在HashMap存储数据的时候会对hash函数返回的散列值进行取余，众所周知，如果除数不大，那么散列值的高位基本上不会参与到地址映射的工作当中，为了使高位也能参与到地址映射，所以进行了第二次异或散列，这样原本key的散列值高位和低位都能尽可能的参与到地址映射当中。

3. **数字分析**

    关键字是r进制数字，那么我们选取关键字中变化较多的几位，通过r进制重新组合成新的数字，将这个新的数字作为地址。这种方式比较局限，因为如果关键字种类换了，那么函数也得跟着换。

4. **折叠法**

    这种方法比较简单，将原本的关键字分割成若干段，然后讲这些段相加，得到地址。

5. **平方取中**

    对关键字进行平方，然后取平方后的值的中间几位作为地址。

<br>

### 散列冲突

上述散列函数中，除了直接定址之外，其他基本上都会产生冲突。冲突并不可怕，关键是要找到解决冲突的办法。一般解决冲突有两种办法：

1. **开放定址法**

    当两个关键字地址发生冲突的时候，使用某种探测技术生成一个探测序列，然后沿着这个探测序列查找下去，如果发现空的单元，则插入。

    公式：H(key)=H(key+di)%m，其中di为增量序列，m为散列表长度

    增量序列有如下四种方式可以生成：

    - `线性探测法`：di=0,1,2,3,4,...,m-1，这也就是说顺着冲突的地址按照顺序往下一个一个地址去看有没有空闲，知道找到一个空地址，将元素存入。这种方式会导致元素堆积。
    - `平方探测法`：di=0^2,1^2,-1^2,2^2,-2^2,...,k^2,-k^2，其中k<=m/2，并且散列表长度m必须可以表示成为4k+3的素数。这种方式可以避免堆积，但是并不能探测全部的地址空间，不过至少也能探测一般。
    - `再散列法`：di=H2(key)，通过公式Hi=(H(key) + i*H2(key))%m，的大豆再散列的值，其中i为再散列的次数，初始为0。这种方式最多经过m-1次探测就可以遍历表中所有位置，回到H0的位置。
    - `伪随机序列法`：di=伪随机数序列，称为伪随机序列法。

2. **链接法**

    将同一散列地址的所有元素存储在一条线性链表中。

3. **桶地址法**

    为表中的每个地址关联一个桶,一个桶可以存储多个元素.如果桶满了,可以使用开放地址法。

<br>

### 性能分析

在分析性能之前，先了解一下散列表的查找过程：

1. 通过key的散列值获取地址，检测表中对应地址是否有记录，如果没有记录，返回查找失败。如果有记录，对比记录的关键字和key是否符合，符合则返回查找成功。不符合则进入步骤2
2. 用给定处理冲突的方式计算下一个散列地址。然后转入步骤1，使用新生成的地址查询

通过散列表查询的过程可以看出：

1. 尽管散列表建立了关键字和存储地址之间的映射，但是由于冲突的存在，导致还是需要通过比较关键字来确定查找元素。所以还是需要使用ASL来评估性能。
2. 散列表查找效率取决于三个因素：散列函数、处理冲突方式、填装因子（如果不知道什么是填装因子去百度）。一般来说填装因子对散列表的效率影响比较大，因为如果填装因子过大，导致填装过满，冲突会加剧。

<br><br><br>

## B树、B+树


