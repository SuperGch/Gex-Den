# 数据结构基础知识：树


## 树的基本概念

<br>

### 树的定义

树是由n（n>=0）个节点和n-1条边构成的有限集。

- n=0，称为空树
- n>0，存在根节点

非空树满足如下条件：

- 有且仅有一个根节点
- 当n>1时，其余节点可以分为m（m>0）个互不相交的有限集，其中每个有限集都是一棵树，称为子树。

由此可见树是一种递归的数据结构，具有两个特点：

1. 树种的根节点没有直接前驱，其余节点有且仅有一个直接前驱。
2. 树种所有节点有0个或者多个直接后继。

<br>

### 描述树的术语

1. 从节点N到根节点的任意一个节点，都成为N的`祖先`，N则成为这些个祖先的`子孙`，N的直接前驱节点成为N的`双亲`，K成为其直接前驱节点的`孩子`，有相同双亲节点的多个节点成为`兄弟`。
2. 树中某个节点的孩子个数成为节点的`度`，树中节点的最大度数为`树的度`。
3. 度大于0的节点为`分支节点`，度为0的节点为`叶子节点`。
4. `节点的层次`：以根节点所在的层数为第1层，根节点的直接子节点所在的层数为第2层，以此类推。
5. `节点的深度`：从上向下的层数。
6. `节点的高度`：从下向上的层数。
7. `树的高度`：树中节点的最大层数。
8. `森林`：森林是m（m>0）棵互不相交的树的集合。

<br>

### 树的性质

1. 节点数=总度数+1
2. 度为m的树第i层至多有m^(i-1)个节点，也就是每个节点的度都是m
3. 高度为h的m叉树，至多有(m^h - 1)*(m-1)个节点，也就是每个节点的度都是m，然后根绝等比数列公式计算所有层上的节点数之和
4. 高度为h的m叉树至少有h个节点，高度为h，度为m的树至少有h+m-1个节点

<br><br><br>

## 二叉树

<br>

### 二叉树的定义

二叉树就是最大度数为2的有序树。何谓有序树，就是节点顺序不可颠倒的树，二叉树中分为左子树和右子树，二者不可颠倒，颠倒就成为另一个二叉树了。

特殊的二叉树：

- `满二叉树`：高度为h且含有2^h - 1个节点的二叉树。按照从上到下、从左到右的顺序依次对节点编号。也就是从1到2^h - 1个号码。
- `完全二叉树`：不一定是满二叉树，但是所有节点的号码与高度相同的满二叉树中对应节点号码相同的二叉树。

![满二叉树和完全二叉树](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/1620308216.png "满二叉树和完全二叉树")

- `二叉排序树`（高频）：左子树上所有节点的号码均小于根节点，右子树上所有节点的号码均大于根节点
- `平衡二叉树`（高频）：树上任意节点的左子树和右子树的深度只差不超过1

<br>

### 二叉树的性质

1. 非空二叉树中第k层，至多有2^(k-1)个节点（k>0）
2. 高度为h的二叉树至多有2^h - 1个节点（h>0）

<br>

### 二叉树存储结构

#### 1. 顺序存储结构

使用一组连续的存储空间自上而下，自左至右地存储二叉树中的所有节点，如果遇到某个位置上没有节点，使用空节点来代替。

所以顺序存储结构更适合存储满二叉树和完美二叉树。

#### 2. 链式存储结构

使用节点将指针将所有节点按照其在二叉树中的关系链接起来。

链表节点有三个域：左指针域、数据域、右指针域。

一般的二叉树都是使用链式存储结构。值得注意的是，在含有n个节点的二叉链表中，含有n+1个空链域，都是叶子节点的左指针域和右指针域。奇数个节点有偶数个空链域，偶数个节点有奇数个空链域。


<br><br><br>

## 二叉树的遍历

这里的遍历都是根据链式存储结构来进行的，具体的数据结构如下所示：

```java
/**
 * 二叉树节点的数据结构
 */
public class BiTree {
    String data;
    BiTree leftChild;
    BiTree rightChild;

    public BiTree(String data, BiTree leftChild, BiTree rightChild) {
        this.data = data;
        this.leftChild = leftChild;
        this.rightChild = rightChild;
    }
}
```

<br>

### 先序遍历（NLR）

- 二叉树为空，啥也不做
- 否则按照如下顺序访问节点：根节点(N)->左子树(L)->右子树(R)

```java
public void print(BiTree tree){
    System.out.println(tree.data);
}

/**
 * 先序遍历
 */
public void preOrder(BiTree tree) {
    // 判断空树
    if(tree != null){
        visit(tree);
        preOrder(tree.lchild);
        preOrder(tree.rchild);
    }
}
```

<br>

### 中序遍历（LNR）

- 二叉树为空，啥也不做
- 否则按照如下顺序访问节点：左子树(L)->根节点(N)->右子树(R)

```java
public void print(BiTree tree){
    System.out.println(tree.data);
}

/**
 * 中序遍历
 */
public void inOrder(BiTree tree) {
    // 判断空树
    if(tree != null){
        inOrder(tree.lchild);
        visit(tree);
        inOrder(tree.rchild);
    }
}
```

<br>

### 后序遍历（LRN）

- 二叉树为空，啥也不做
- 否则按照如下顺序访问节点：左子树(L)->右子树(R)->根节点(N)

```java
public void print(BiTree tree){
    System.out.println(tree.data);
}

/**
 * 后序遍历
 */
public void postOrder(BiTree tree) {
    // 判断空树
    if(tree != null){
        postOrder(tree.lchild);
        postOrder(tree.rchild);
        visit(tree);
    }
}
```

### 非递归遍历

上述三种遍历方式都使用了递归的手法，无非就是调整一下访问当前节点数据的函数位置罢了，每个节点都只访问一次，时间复杂度为O(n)，最坏空间复杂度为O(n)。

那么问题随之而来，如果不借助递归的话，该如何对二叉树进行前序、中序、后序遍历呢？

通过使用`栈`可以解决这个问题，栈的特性是先进后出(FILO)，由此可以得到如下使用非递归算法解决遍历的思路。

1. **先序遍历**

    ① 从根节点开始，访问当前节点并且入栈，如果左孩子不为空，一直重复①

    ② 左孩子为空则开始出栈，判断当前节点的右节点是否存在，为空则继续执行②，否则执行①

    ```java
    public void print(BiTree tree){
        System.out.println(tree.data);
    }

    public void preOrderNonRecursive(BiTree tree){
        // 使用链表当做栈
        Deque<BiTree> stack = new LinkedList<>();
        // 如果当前节点存在左孩子 或者 栈不为空
        while(tree!=null || !stack.isEmpty()){
            if(tree){
                visit(top);
                stack.push(tree);
                tree = tree.leftChild;
            }else{
                BiTree top = stack.pop();
                tree = top.rightChild;
            }
        }
    }
    ```

2. **中序遍历**

    ① 从根节点依次将左孩子压入栈，直到左孩子为空，表明可以出栈了

    ② 从栈顶拿到一个节点读取，然后判断其右孩子是否为空，为空则继续执行②，否则执行①

    ```java
    public void print(BiTree tree){
        System.out.println(tree.data);
    }

    public void inOrderNonRecursive(BiTree tree){
        // 使用链表当做栈
        Deque<BiTree> stack = new LinkedList<>();
        // 如果当前节点存在左孩子 或者 栈不为空
        while(tree!=null || !stack.isEmpty()){
            if(tree){
                stack.push(tree);
                tree = tree.leftChild;
            }else{
                BiTree top = stack.pop();
                visit(top);
                tree = top.rightChild;
            }
        }
    }
    ```

3. **后序遍历（三种非递归中最难）**

    ① 从根节点开始一次将左孩子压入栈，直到左孩子为空

    ② 判断当前栈顶节点是否存在右子树或者右子树被完全访问，不存在或者已被完全访问则出栈访问并且继续执行②，否则对右子树执行①

    ```java
    public void print(BiTree tree){
        System.out.println(tree.data);
    }

    public void postOrderNonRecursive(BiTree tree){
        // 定义变量来标记最近访问的节点，用于判断右子树是否完全访问了
        BiTree recentPop = null;
        // 使用链表当做栈
        Deque<BiTree> stack = new LinkedList<>();
        // 如果当前节点存在左孩子 或者 栈不为空
        while(tree!=null || !stack.isEmpty()){
            if(tree){
                stack.push(tree);
                tree = tree.leftChild;
            }else{
                // 如果右子树存在并且没有被访问过，压栈
                tree = stack.peek();
                if(tree.rightChild!=null && tree.rightChild != recentPop){
                    tree = tree.rightChild;
                    stack.push(tree);
                    tree = tree.leftChild;
                }else{
                    BiTree top = stack.pop();
                    visit(top);
                    recentPop = top;
                    // 将tree置为null，这样就会继续进入到判断栈顶元素是否存在右子树的环节了
                    tree = null;
                }
                // 否则访问栈顶节点，并且记录最近访问的这个节点
            }
        }
    }
    ```

<br>

### 层序遍历

使用队列，步骤如下：

1. 根节点开始入队
2. 然后出队，读取根节点元素，然后将根节点的子节点从左至右入队
3. 以此类推，知道所有元素遍历完成

<br><br><br>

## 二叉排序树（BST）

<br>

### 二叉排序树的定义
二叉排序树（BinarySortTree）又称为二叉查找树（BinarySearchTree）。除了空树以外，二叉排序树的特征如下：

1. 若左子树非空，则左子树上所有节点的值均小于根节点的值
2. 若右子树非空，则右子树上所有节点的值均小于根节点的值
3. 左右子树分别也是一颗二叉排序树

由上述特征可以得到：中序遍历二叉排序树，可以得到一个递增的序列。

<br>

### 二叉排序树的操作

1. **查找**

    先将给定的值同根节点比较，相同则查找完成。给定的值小于根节点值，在左子树查找，否则在右子树查找。

    很明显，这种查找也是一个递归的过程。所以产生了两种查找算法：递归算法和非递归算法。

    递归算法实现：
    ```java
    /**
     * 递归算法：
     * 在给定的二叉查找树tree中搜索给定的key值，并且返回对应的节点
     */
    BiTree BSTSearch(BiTree tree, String key){
        if(key==null || tree==null){
            return null;
        }
        if(key.equals(tree.data)){
            // 如果查找到了则返回
            return tree;
        }else{
            // 没有查找到，判断值的大小
            if(key.compareTo(tree.data)<0){
                return BSTSearch(tree.leftChild, key);
            }else{
                return BSTSearch(tree.rightChild, key);
            }
        }
    }
    ```

    非递归算法实现：
    ```java
    /**
     * 非递归算法：
     * 在给定的二叉查找树tree中搜索给定的key值，并且返回对应的节点
     */
    BiTree BSTSearch(BiTree tree, String key){
        if(key==null) {
            return null;
        }
        // 当树不为空并且没有找到合适的值时，继续循环
        while(tree!=null && !key.equals(tree.data)){
            if(key.compareTo(tree.data)<0){
                tree = tree.leftChild;
            }else{
                tree = tree.rightChild;
            }
        }
        return tree;
    }
    ```

2. **插入**

    二叉树是动态树，如果没有在二叉树中找到对应的值，那么就将该值插入到二叉树里面。在这个过程中，如果原本二叉树不为空，则最后查找的节点一定是叶子节点，也就是说该值将被插入到这个叶子节点上作为其孩子。

    二叉树的插入算法实现：
    ```java
    /**
    * 将制定的值包装成二叉树的节点插入到二叉树当中
    */
    int BSTInsert(BiTree tree, String key){
        if(key==null){
            return 0;
        }
        if(tree==null){
            // 原本的二叉树为空
            tree = new BiTree(key, null, null);
            return 1;
        }else if(key.equals(tree.data)){
            // 原本的二叉树中存在key值
            return 0;
        }else if(key.compareTo(tree.data)<0>){
            // 在左子树中查找插入
            return BSTInsert(tree.leftChild, key);
        }else{
            // 在右子树中查找插入
            return BSTInsert(tree.rightChild, key);
        }
    }
    ```

3. **删除**

    三种情况处理：

    - 如若删除的节点没有左右孩子，直接删除
    - 如若删除的节点仅有左子树或者右子树，那么删除该节点之后，让子树成为父节点的子树
    - 如果删除的节点存在左右子树，那么使用右子树中序遍历的第一个节点A替换当前被删除节点，并且随后删除节点A，由于节点A一定是上述两种情况中的一种，所以删除起来比较方便

4. **构造**

    构造的意思就是：给定一个有序序列，将其构造成二叉排序树。

    思路：遍历有序序列，对其中所有的值调用BSTInsert方法进行插入，遍历完成之后就生成了二叉排序树。

5. **效率分析**

    如果二叉排序树左右子树的高度差不超过1，那么平均查找长度为O(log2n)

    如果二叉排序树仅有单边子树，那么平均查找长度为O(n)

    同时对于插入删除这些维护操作来说，二叉排序树不会移动任意节点，秩序改变指针指向。所以平均执行时间为O(log2n)。

    下面同二分查找进行对比：

    ||查找|插入|删除|
    |---|---|---|---|
    |二分查找|log2n|n|n|
    |二叉排序树|log2n|log2n|log2n|

    二分查找判定树唯一，而二叉排序树不唯一。

    所以如果对于静态序列建议使用二分查找，对于动态序列建议使用二叉树。

<br><br><br>

## 平衡二叉树（AVL）

二叉排序树可能会带来树高增长过快的问题，导致一些操作算法性能上并不能发挥出其最大优势，所以引入了平衡二叉树。

<br>

### 平衡二叉树定义

所谓平衡二叉树，就是左右子树均为平衡二叉树，且左右子树的高度差不大于1。

<br>

### 平衡二叉树的插入

平衡二叉树的插入相对于普通二叉排序树的插入多了一个步骤，当节点插入完成之后，如果导致离当前插入节点路径最近的节点A进入了不平衡状态，那么还需要调整节点A的子树使其重归平衡状态。

总共有以下四种情况：

1. LL平衡旋转（右单旋转）

    向A左子树的左节点插入节点N导致节点A失衡。

    ![LL平衡旋转动画](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/BBT-LLRotate.gif "LL平衡旋转动画")

2. RR平衡旋转（左单旋转）

    向A右子树的右节点插入节点N导致节点A失衡。

    ![RR平衡旋转动画](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/BBT-RRotate.gif "RR平衡旋转动画")

3. LR平衡旋转（先左后右双旋转）

    向A左子树的右节点插入节点N导致节点A失衡。

    ![LR平衡旋转动画](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/BBT-LRotate.gif "LR平衡旋转动画")

4. RL平衡旋转（先右后左双旋转）

    向A右子树的左节点插入节点N导致节点A失衡。

    ![RL平衡旋转动画](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/BBT-RLRotate.gif "RL平衡旋转动画")

<br><br><br>

## 红黑树（Red Black Tree RBT）

红黑树本质上是一种二叉查找树，但它在二叉查找树的基础上额外添加了一个标记（颜色），同时具有一定的规则。这些规则使红黑树保证了一种平衡，插入、删除、查找的最坏时间复杂度都为 O(logn)。

<br>

### 红黑树的定义

`红黑树`：一种含有红黑结点并能自平衡的二叉排序树（BST）。

`黑色高度`：从根节点到叶子节点的路径上黑色节点的个数，叫做树的黑色高度。

红黑树常用的性质：

1. 节点要么黑色要么红色
2. 根节点是黑色
3. 每个叶子节点是黑色，并且都是空节点（Java 实现的红黑树将使用 null 来代表空节点，遍历红黑树时将看不到黑色的叶子节点，反而看到每个叶子节点都是红色的）
4. 每个红色节点的两个子节点都一定是黑色
5. 任意一结点到每个叶子结点的路径都包含数量相同的黑结点，即左子树和右子树的黑结点的层数是相等的，所以称红黑树为**黑色完美平衡**

红黑树并不是标准平衡二叉树，它以性质 5 作为一种平衡方法，使自己的性能得到了提升。

红黑树通过三个操作来保证自平衡：左旋、右旋、着色。其中左旋和右旋和平衡二叉树的LL、RR类似，着色就是将节点颜色由黑变红或者由红变黑。

<br><br><br>

### 红黑树的插入

红黑树的插入分为两个步骤：

1. 像BST一样进行查找，然后插入
2. 调整红黑树的结构，保证满足红黑树的性质：左旋、右旋、着色操作

所以研究红黑树的插入，重点研究的是红黑树如何在插入后调整结构达到自平衡。

下面是插入过程中字母所表示的节点：

![插入过程中节点名称](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/RBT-insert-node-names.png "插入过程中节点名称")

#### 插入后调整思路

1. 如果插入根节点，那么直接插入改为黑色即可
2. 如果不是根节点，则需要关注父节点P是否为红色：如果P为黑色，插入后不需要调整；如果P为红色，表明N和P颜色冲突了，这个时候就需要使用父兄节点U来进行旋转操作，使红黑树达到平衡。
3. U为红色，那么P、U都置为黑色，G置为红色，解决了红色冲突，并且保证了黑色层数不变，但随之带来了另一个问题，G和G的父节点是否会红色冲突呢？如果冲突就需要将G重新作为新增节点N重复插入操作了。
4. U为黑色，为了解决红色冲突，需要将一个红色插入到另一边的两个黑色之间，那么这个时候进行旋转即可达到效果，具体情况下图有详细说明。

![红黑树插入思路](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/RBT-insert-mind-mapping.png "红黑树插入思路")

#### 具体调整情况

1. **父亲节点为红色，叔叔节点为红色，祖父节点为黑色**

    假设插入节点N，N为红色，那么为了保证性质4，则父亲节点必须更改为黑色，同时祖父节点更改为红色，随之带来的就是叔叔节点更改为黑色。

    ![情况1着色更改](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/情况1着色更改.jpeg "情况1着色更改")

    上述着色更改之后，带来一个问题，就是祖父节点改为红色之后，其父亲节点会不会也是红色，解决办法：如果祖父节点的父亲节点也是红色，那么就将祖父节点当成新添加的节点，继续重复上述操作，知道不会出现两个红色节点相连为止。

    情况1中新节点插入到左节点和右节点处理方式相同，故不做其他说明。

2. **父亲节点为红色，叔叔节点为黑色，祖父节点为黑色**

    假设插入节点N，N为红色，那么为了保证性质4，把父亲节点更改为黑色，那么多了一个黑色节点，违背性质5。仅仅改色目前看上去不太行了，那么只能旋转了。

    目前看来右旋比较合适，因为左旋会导致叔叔路径上少了一个黑色节点。将父亲节点作为根节点，祖父节点作为父亲节点的子节点，叔叔节点还是祖父节点的子节点。旋转完成之后，父亲节点作为根节点是黑色，新增节点是红色，祖父节点改为红色，叔叔节点保持黑色，这样就完成了调整。

    ![情况2旋转+着色](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/RBT-LRotate.gif "情况2旋转+着色")

    如果节点N插入在父亲节点的右节点，那么在进行情况2之前还需要对节点P进行一次左旋，然后在进行右旋-着色的操作。

    ![情况2插入右节点先左旋](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/RBT-LRotate-RRotate.jpeg "情况2插入右节点先左旋")

    总结完之后发现这种情况不存在，因为祖父节点左子树和右子树的黑色层数不同。目前是这么认为的，如果有思维盲点欢迎指正。

### 红黑树的删除

红黑树的删除也同样分为两个步骤：

1. BST删除节点操作
2. 结构调整

删除过程中的字母标识如下所示：

![删除过程中节点名称](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/RBT-delete-node-names.png "删除过程中节点名称")

#### BST删除节点操作回顾

前面说了BST删除节点有如下三种情况：

1. 如若删除的节点没有左右孩子，直接删除
2. 如若删除的节点仅有左子树或者右子树，那么删除该节点之后，让子树成为父节点的子树
3. 如果删除的节点存在左右子树，那么使用右子树中序遍历的第一个节点A替换当前被删除节点，并且随后删除节点A，由于节点A一定是上述两种情况中的一种，所以删除起来比较方便

三种情况过于复杂，不过自己看图按照删除的流程走了几遍之后，发现了一个思路：
`所有的上述三种情况，最终删除的都是叶子节点，也就是情况1`。

如果按照上述三种情况来解释未免有点牵强，所以将上述三种删除情况改进一下：

1. 叶子节点直接删除
2. 如果删除的节点有左子树或者右子树，首先取右子树最左节点A（如果没有右子树则取左子树最右节点）替换当前删除节点，如果替换节点A也存在子树，那么继续使用其子树中的节点替换A，直到最后一个替换节点Z不存在子节点，也就是说最后的节点Z是叶子节点，那么删除Z即可。

从改进的之后的情况中可以发现，我们可以认为最终删除的都是叶子节点。


#### 删除后的调整思路

对于红色的叶子节点，删除之后并不会影响红黑树的平衡，所以只需要关注黑色叶子节点的删除。

而删除了黑色节点表示有一边少了一层黑色，有两种处理方式：

1. 将另一边也减少一层黑色，然后再以父节点P作为节点N继续执行删除操作，进行递归处理
2. 通过一系列高端操作，让删除的这边增加一层黑色，从而达到平衡

上面说起来很简单，可以通过以下故事通俗理解：

假如说，我需要2枚硬币，这时候我们一般的做法可以看做下面几步：

1. 自己有吗？（）
2. 自己没有的话，兄弟有吗？
3. 兄弟没有的话，兄弟的孩子有吗？
4. 连兄弟的孩子都没有的话？那我们会托父母找亲戚看看有没有

下面是总结的删除思维导图：

![红黑树删除思路](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/RBT-delete-mind-mapping-fixed.png "红黑树删除思路")

#### 具体调整情况

1. **删除的叶子节点N为根节点**

    无需自平衡。

2. **删除的叶子节点N有兄弟节点S**

    2.1. 兄弟节点S为红色（表明可以借用兄弟节点的红色）

    - S为P的左节点，以P为轴进行右旋，S、P交换颜色

        ![2.1-1](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/BST-delete-2.1-1.png "S为红色左节点")

    - S为P的右节点，以P为轴进行左旋，S、P交换颜色

        ![2.1-2](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/BST-delete-2.1-2.png "S为红色右节点")

    2.2. 兄弟节点S为黑色（表明无法借用兄弟节点的红色，那么我们看看兄弟节点的孩子）

    2.2.1 兄弟节点S的孩子均为黑色（也无法借用兄弟节点孩子的红色）

    - P为红色：S和P交换颜色

        ![2.2.1-1 P为红色](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/BST-delete-2.2.1-2.png "P为红色")

    - P为黑色：S变为红色，将P当做N做递归删除处理（这里P的两遍黑色层数都减少了1）

        ![2.2.1-2 P为黑色](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/BST-delete-2.2.1-2.png "P为黑色")

    2.2.2 兄弟节点S的孩子存在红色

    - SL红：按照下图，以P为轴进行右旋，S变为新P，同时S置为P的颜色，P变为黑色，SL变为黑色，SR变为P的左子节点。

        ![2.2.2-1 SL红](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/BST-delete-2.2.2-1.png "SL红")

    - SL黑、SR红：分为两步走，1. 以S为轴进行左旋，SR变为P的左子节点，S变为SR的左子节点，SL还是S的左子节点，同时交换SR与S的颜色，此时SR是黑色，S是红色；2. 此时情况转换为了上述情况，以P为轴进行右旋，SR变为了新P，同时SR置为P的颜色，P变为黑色，S变为黑色

        ![2.2.2-2 SL黑、SR红](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/BST-delete-2.2.2-2.png "SL黑、SR红")


<br>

### 红黑树的疑问

经过了上述插入删除两个操作的学习，对红黑树有了更深入的了解。接下来看看红黑树的几个问题：

#### 1. 红黑树根节点为什么是黑色的？

因为如果根节点是红色，那么想要给只有一个根节点的红黑树中插入元素就需要转换颜色或者进行旋转，用来达到所有路径上的黑色层数相同。所以如果根节点本身就是黑色，那就不用那么麻烦，说白了就是懒。

#### 2. 为什么不能有两个连续的红色节点？

为了保证路径长度的相对平衡，因为所有路径上的黑色层数n都相同，从根节点到叶子节点的最短路径一定全是黑色节点，故路径长度为n，而最长路径则是相连的两个黑色节点中间都插入一个红色节点，故路径长度为2n，这就保证了即使是最长的路径也只是最短路径的2倍。

#### 3. 红黑树的效率怎么样？

`查找时间复杂度`：查找自然不用多说，RBT的查找时间复杂度为O(logN)，但是相比AVL的还是要逊色不少，因为AVL是严格平衡二叉树，子树高度差不超过1，也就是说从根节点到任何叶子节点路径长度大致相同，而RBT从根节点到叶子节点所有路径长度最大差值为一倍黑色层高。

`插入和删除时间复杂度`：RNT的插入和删除时间复杂度和查询时间复杂度相当，是O(logN)（具体怎么证明，后面再补充，已经学费了）

由于RBT不想AVL一样追求完美平衡，所以插入和删除操作过程中的平衡操作比AVL少了不少。但是RBT又能保证黑色平衡，相比BST要好了不少。所以个人理解RBT就是BST和AVL的一个折中。具体使用还得看场景，没有孰好孰不好。

<br><br><br>

## 哈弗曼树与哈夫曼编码

<br>

### 哈弗曼树的定义

了解什么是哈弗曼树之前，首先了解下面这些定义：

`权`：树中节点被赋予的一个有意义的值，成为该节点的权值。

`带权路径长度`：从树的根节点到节点N上的路径长度与节点N的权值的乘积，称为带权路径长度。使用WPL表示。

有了权值和带权路径长度，就可以很轻松地定义一个哈弗曼树了：

`哈弗曼树`：在含有n个（n>0）带权叶节点的二叉树中，其中带权路径长度WPL最小的二叉树成为哈弗曼树，也叫做最优二叉树。

<br>

### 构造哈弗曼树

`构造步骤`：

1. 将n个节点分别当做n棵树来对待，他们就构成了森林F
2. 构造一个新节点，从森林当中拿出两个权值最小的树，将这两棵树分别作为新节点的左右子树，得到的新树的权值即为左右两个节点的权值之和
3. 从森林F中删除刚才选中的两棵树，将新生成的子树添加到森林F中
4. 重复步骤2、3，直到森林F中只剩下一棵树，那么这棵树就是所谓的哈弗曼树

通过上述步骤可以总结出哈弗曼树的特点：

1. 每个初始节点最注重都成为了叶子节点，并且权值越小距离跟节点路径越长
2. 构造过程中共新建了n-1个新节点，所以哈弗曼树总共具有2n-1个节点
3. 哈弗曼树不存在度为1的节点，所有节点的度要么0要么2

<br>

### 哈夫曼编码

`固定长度编码`：每个字符使用相等长度的二进制编码。

`可变长度编码`：允许对不同字符使用不同长度的二进制编码。

上述两种编码，当然是可变长度编码好了，可以对高频字符使用更短长度的编码，对低频字符的编码可以更长一点，从而达到压缩数据的效果。

而哈夫曼编码就是用字符出现的频次作为其权值，出现次数越少，路径越长，出现次数越多路径越短。对于哈弗曼树，规定权值为字符出现的频次，每次向左表示0，向右表示1，则构建出了如下示例的哈弗曼树，其中叶子节点的值分别是ABCD：

![哈弗曼编码示例](https://cdn.jsdelivr.net/gh/SuperGch/picgo/note-imgs/HuffmanCodingExample.jpeg "哈弗曼编码示例")

如果根据上图有一串编码`0011011110`，需要将这串编码翻译出来，那么得到的结果是`AACDB`，可以发现所有ABCD四个字母对应的编码互相都不是其他字母编码的前缀，这样就可以很轻松的根据前缀来识别出具体的编码。（考试千万不要用来干坏事哦[狗头]）

